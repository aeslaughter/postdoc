<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>NSF Postdoctoral Research: SlaughterFEM::EqBase&lt; Type, TypeBoundaryBase &gt; Class Template Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/MathJax.js"></script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">NSF Postdoctoral Research
   
   </div>
   <div id="projectbrief">A set of C++ code developed by Andrew E. Slaughter</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('class_slaughter_f_e_m_1_1_eq_base.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">SlaughterFEM::EqBase&lt; Type, TypeBoundaryBase &gt; Class Template Reference<div class="ingroups"><a class="el" href="group___f_e_mcommon.html">General FEM related code</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="SlaughterFEM::EqBase" --><!-- doxytag: inherits="SlaughterFEM::EqCore,System::Assembly,System::Initialization" -->
<p>A template base class for using libmesh to solve equations.  
 <a href="class_slaughter_f_e_m_1_1_eq_base.html#details">More...</a></p>

<p><code>#include &lt;fem/common/eq_base.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SlaughterFEM::EqBase&lt; Type, TypeBoundaryBase &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="class_slaughter_f_e_m_1_1_eq_base__inherit__graph.png" border="0" usemap="#_slaughter_f_e_m_1_1_eq_base_3_01_type_00_01_type_boundary_base_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="_slaughter_f_e_m_1_1_eq_base_3_01_type_00_01_type_boundary_base_01_4_inherit__map" id="_slaughter_f_e_m_1_1_eq_base_3_01_type_00_01_type_boundary_base_01_4_inherit__map">
<area shape="rect" id="node2" href="class_slaughter_f_e_m_1_1_eq_core.html" title="A class containing methods for accessing libMesh::Systems This class is meant to be a inherited from ..." alt="" coords="67,5,277,35"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for SlaughterFEM::EqBase&lt; Type, TypeBoundaryBase &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="class_slaughter_f_e_m_1_1_eq_base__coll__graph.png" border="0" usemap="#_slaughter_f_e_m_1_1_eq_base_3_01_type_00_01_type_boundary_base_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="_slaughter_f_e_m_1_1_eq_base_3_01_type_00_01_type_boundary_base_01_4_coll__map" id="_slaughter_f_e_m_1_1_eq_base_3_01_type_00_01_type_boundary_base_01_4_coll__map">
<area shape="rect" id="node2" href="class_slaughter_f_e_m_1_1_eq_core.html" title="A class containing methods for accessing libMesh::Systems This class is meant to be a inherited from ..." alt="" coords="67,5,277,35"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="class_slaughter_f_e_m_1_1_eq_base-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_slaughter_f_e_m_1_1_eq_base.html#abb60c3ae168ffdeb7df94831c6ff3a4e">init_equation_system</a> (Real t_initial=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the equation system.  <a href="#abb60c3ae168ffdeb7df94831c6ff3a4e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_slaughter_f_e_m_1_1_eq_base.html#a49aee018d9e5bb74ccceb2c0be3dd96b">update_solution</a> (Real time, Real dt)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the solution with time.  <a href="#a49aee018d9e5bb74ccceb2c0be3dd96b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_slaughter_f_e_m_1_1_eq_base.html#a4e952640e5fa5efceba09cbfaa8e751b">use_refinement</a> (int n=5)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable mesh refinement.  <a href="#a4e952640e5fa5efceba09cbfaa8e751b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_slaughter_f_e_m_1_1_eq_base.html#a1abc4c56b6027b5ab67bbab8b3d97842">set_refinement_levels</a> (double refine_fraction, double coarsen_fraction, int max_h_level)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the mesh refienement critiera.  <a href="#a1abc4c56b6027b5ab67bbab8b3d97842"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_slaughter_f_e_m_1_1_eq_base.html#a77adb3eb00c99dd5cd350ebfb386998d">add_initial_function</a> (<a class="el" href="group___f_e_mcommon.html#ga41eb588aa7e5f7fb528a7cccecd651e9">eq_base_init_func_libmesh</a> func)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a function pointer to the initialization function.  <a href="#a77adb3eb00c99dd5cd350ebfb386998d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_slaughter_f_e_m_1_1_eq_base.html#a82e8f16c4644843f561a5e9e14d817dc">add_initial_function</a> (<a class="el" href="group___f_e_mcommon.html#gaa2cfca47e0fda7e9c260b0e6471a9f90">eq_base_init_func_boost</a> func)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add function pointer to act as initialization function using boost::function indirectly.  <a href="#a82e8f16c4644843f561a5e9e14d817dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_slaughter_f_e_m_1_1_eq_base.html#a34534f74c45909a599d7edbfde107d46">add_initial_function</a> (boost::function&lt; void(DenseVector&lt; Number &gt; &amp;output, const Point &amp;, const Real)&gt; bst_fptr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a boost::function pointer act as initialization function.  <a href="#a34534f74c45909a599d7edbfde107d46"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TypeNewBoundary &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">boost::shared_ptr<br class="typebreak"/>
&lt; TypeNewBoundary &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_slaughter_f_e_m_1_1_eq_base.html#a7304b13e3f3967bd98c593b52035f3ea">add_boundary</a> (int id)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a boundary object.  <a href="#a7304b13e3f3967bd98c593b52035f3ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_slaughter_f_e_m_1_1_eq_base.html#a9007ab95daa89b5dee8c09508ff02fa3">solve</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the equation system for this class.  <a href="#a9007ab95daa89b5dee8c09508ff02fa3"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_slaughter_f_e_m_1_1_eq_base.html#a3bf72710ab96b134ce17cc70aed43761">EqBase</a> (EquationSystems &amp;sys, string <a class="el" href="class_slaughter_f_e_m_1_1_eq_core.html#a5243bf4ffee310366ffc311f362f6d28">name</a>, const Order order=SECOND)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class constructor.  <a href="#a3bf72710ab96b134ce17cc70aed43761"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d69a73580cd53bfe61e9c1d4c2faf3d"></a><!-- doxytag: member="SlaughterFEM::EqBase::assemble" ref="a3d69a73580cd53bfe61e9c1d4c2faf3d" args="()=0" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_slaughter_f_e_m_1_1_eq_base.html#a3d69a73580cd53bfe61e9c1d4c2faf3d">assemble</a> ()=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">libMesh assembly function <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6589647ca0ba0ece71aa351f4c564e13"></a><!-- doxytag: member="SlaughterFEM::EqBase::initialize" ref="a6589647ca0ba0ece71aa351f4c564e13" args="()" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_slaughter_f_e_m_1_1_eq_base.html#a6589647ca0ba0ece71aa351f4c564e13">initialize</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">libMesh initilize function <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6d7b20c431b8f4908a56733846d4e18"></a><!-- doxytag: member="SlaughterFEM::EqBase::apply_dirichlet" ref="ab6d7b20c431b8f4908a56733846d4e18" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_slaughter_f_e_m_1_1_eq_base.html#ab6d7b20c431b8f4908a56733846d4e18">apply_dirichlet</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the libMesh based Dirichlet boundary condition. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_slaughter_f_e_m_1_1_eq_base.html#a308250b3db51f34ae39dc4ec3927fcda">get_boundary_index</a> (const int id)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A method for getting a vector of indices for the boundary id.  <a href="#a308250b3db51f34ae39dc4ec3927fcda"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e16472e7691e601798855f90a29ef4d"></a><!-- doxytag: member="SlaughterFEM::EqBase::using_mesh_refinement" ref="a5e16472e7691e601798855f90a29ef4d" args="" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_slaughter_f_e_m_1_1_eq_base.html#a5e16472e7691e601798855f90a29ef4d">using_mesh_refinement</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A flag for using mesh refinement. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66f25e974403f1f55fbc6c260bda56dc"></a><!-- doxytag: member="SlaughterFEM::EqBase::refine_ptr" ref="a66f25e974403f1f55fbc6c260bda56dc" args="" -->
boost::shared_ptr&lt; MeshRefinement &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_slaughter_f_e_m_1_1_eq_base.html#a66f25e974403f1f55fbc6c260bda56dc">refine_ptr</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A shared pointer to the mesh refinement object created. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e30a9728e5b453e92d2df36d656b27f"></a><!-- doxytag: member="SlaughterFEM::EqBase::max_r_steps" ref="a2e30a9728e5b453e92d2df36d656b27f" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_slaughter_f_e_m_1_1_eq_base.html#a2e30a9728e5b453e92d2df36d656b27f">max_r_steps</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of refinement steps allowed. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeaa7c006c8f3ceb5a84534557174906b"></a><!-- doxytag: member="SlaughterFEM::EqBase::init_func" ref="aeaa7c006c8f3ceb5a84534557174906b" args="" -->
<a class="el" href="group___f_e_mcommon.html#ga41eb588aa7e5f7fb528a7cccecd651e9">eq_base_init_func_libmesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_slaughter_f_e_m_1_1_eq_base.html#aeaa7c006c8f3ceb5a84534557174906b">init_func</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to the initialization function. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a696a292e8c24a62b1c9fc752cdfbae1e"></a><!-- doxytag: member="SlaughterFEM::EqBase::bst_init_func" ref="a696a292e8c24a62b1c9fc752cdfbae1e" args="" -->
boost::function&lt; void(DenseVector<br class="typebreak"/>
&lt; Number &gt; &amp;output, const <br class="typebreak"/>
Point &amp;, const Real)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_slaughter_f_e_m_1_1_eq_base.html#a696a292e8c24a62b1c9fc752cdfbae1e">bst_init_func</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A boost::function for initialization. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9fa5613e1c7582cfcc5d4502ab83c54"></a><!-- doxytag: member="SlaughterFEM::EqBase::bc_ptrs" ref="af9fa5613e1c7582cfcc5d4502ab83c54" args="" -->
vector&lt; boost::shared_ptr<br class="typebreak"/>
&lt; TypeBoundaryBase &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_slaughter_f_e_m_1_1_eq_base.html#af9fa5613e1c7582cfcc5d4502ab83c54">bc_ptrs</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage vector for added boundaries. <br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Type, class TypeBoundaryBase = EqBoundaryBase&gt;<br/>
class SlaughterFEM::EqBase&lt; Type, TypeBoundaryBase &gt;</h3>

<p>A template base class for using libmesh to solve equations. </p>
<p>Provides mechanism for defining a libMesh equation system. It utilizes the <a class="el" href="class_slaughter_f_e_m_1_1_eq_boundary_base.html" title="A base class for equation boundary conditions for integration with EqBase class.">EqBoundaryBase</a> class for implementing boundary conditions.</p>
<p>This class must be inherited and the pure virtual function must be defined in the inherited class.</p>
<p>The public members are designed to be used by the use in their main program. The protected members, although some must be defined, should not be needed by the user once defined.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_slaughter_f_e_m_1_1_heat_eq.html" title="A class for solving the heat equation with libMesh.">HeatEq</a> </dd>
<dd>
example1.cpp </dd>
<dd>
example2.cpp </dd></dl>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a3bf72710ab96b134ce17cc70aed43761"></a><!-- doxytag: member="SlaughterFEM::EqBase::EqBase" ref="a3bf72710ab96b134ce17cc70aed43761" args="(EquationSystems &amp;sys, string name, const Order order=SECOND)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, class TypeBoundaryBase = EqBoundaryBase&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_slaughter_f_e_m_1_1_eq_base.html">SlaughterFEM::EqBase</a>&lt; Type, TypeBoundaryBase &gt;::<a class="el" href="class_slaughter_f_e_m_1_1_eq_base.html">EqBase</a> </td>
          <td>(</td>
          <td class="paramtype">EquationSystems &amp;&#160;</td>
          <td class="paramname"><em>sys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Order&#160;</td>
          <td class="paramname"><em>order</em> = <code>SECOND</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Class constructor. </p>
<p>The <a class="el" href="class_slaughter_f_e_m_1_1_eq_base.html" title="A template base class for using libmesh to solve equations.">EqBase</a> class is designed to be inherited, thus the constructor is protected.</p>
<p>When inheriting this class it is import to explicitly call this constructor in the constructor of the inheriting class, otherwise the class will not function properly. See the <a class="el" href="class_slaughter_f_e_m_1_1_heat_eq.html" title="A class for solving the heat equation with libMesh.">HeatEq</a> class for an example.</p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">Type</td><td>The type of libmesh system to be added, e.g., TransientLinearImplicitSystem as in the <a class="el" href="class_slaughter_f_e_m_1_1_heat_eq.html" title="A class for solving the heat equation with libMesh.">HeatEq</a> class. </td></tr>
    <tr><td class="paramname">TypeBoundaryBase</td><td>The base class for the boundary conditions. By default it uses <a class="el" href="class_slaughter_f_e_m_1_1_eq_boundary_base.html" title="A base class for equation boundary conditions for integration with EqBase class.">EqBoundaryBase</a> but the user might what to change this to use an inherited class of <a class="el" href="class_slaughter_f_e_m_1_1_eq_boundary_base.html" title="A base class for equation boundary conditions for integration with EqBase class.">EqBoundaryBase</a>, again as done in the <a class="el" href="class_slaughter_f_e_m_1_1_heat_eq.html" title="A class for solving the heat equation with libMesh.">HeatEq</a> class.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sys</td><td>A libmesh EquationSystems to work from </td></tr>
    <tr><td class="paramname">name</td><td>The name of the system being created </td></tr>
    <tr><td class="paramname">order</td><td>The order to use for the created equation</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_slaughter_f_e_m_1_1_heat_eq.html" title="A class for solving the heat equation with libMesh.">HeatEq</a> </dd></dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a7304b13e3f3967bd98c593b52035f3ea"></a><!-- doxytag: member="SlaughterFEM::EqBase::add_boundary" ref="a7304b13e3f3967bd98c593b52035f3ea" args="(int id)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, class TypeBoundaryBase = EqBoundaryBase&gt; </div>
<div class="memtemplate">
template&lt;class TypeNewBoundary &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;TypeNewBoundary&gt; <a class="el" href="class_slaughter_f_e_m_1_1_eq_base.html">SlaughterFEM::EqBase</a>&lt; Type, TypeBoundaryBase &gt;::<a class="el" href="class_slaughter_f_e_m_1_1_eq_base.html#a7304b13e3f3967bd98c593b52035f3ea">add_boundary</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a boundary object. </p>
<p>A template class for adding a boundary condition</p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">TypeNewBoundary</td><td>The type of boundary being added. The type added must be derived from <a class="el" href="class_slaughter_f_e_m_1_1_eq_boundary_base.html" title="A base class for equation boundary conditions for integration with EqBase class.">EqBoundaryBase</a>. See example1.cpp for an example.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The integer identification for the boundary</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_slaughter_f_e_m_1_1_eq_boundary_base.html" title="A base class for equation boundary conditions for integration with EqBase class.">EqBoundaryBase</a> </dd>
<dd>
example1.cpp </dd></dl>

</div>
</div>
<a class="anchor" id="a77adb3eb00c99dd5cd350ebfb386998d"></a><!-- doxytag: member="SlaughterFEM::EqBase::add_initial_function" ref="a77adb3eb00c99dd5cd350ebfb386998d" args="(eq_base_init_func_libmesh func)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, class TypeBoundaryBase = EqBoundaryBase&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_slaughter_f_e_m_1_1_eq_base.html">SlaughterFEM::EqBase</a>&lt; Type, TypeBoundaryBase &gt;::<a class="el" href="class_slaughter_f_e_m_1_1_eq_base.html#a77adb3eb00c99dd5cd350ebfb386998d">add_initial_function</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_e_mcommon.html#ga41eb588aa7e5f7fb528a7cccecd651e9">eq_base_init_func_libmesh</a>&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a function pointer to the initialization function. </p>
<p>This version uses the libmesh documented method for adding initial conditions for an equation system. It must be specified in a function with the format given below. (see libMesh help for input format).</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>A function pointer to the initialization function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a82e8f16c4644843f561a5e9e14d817dc"></a><!-- doxytag: member="SlaughterFEM::EqBase::add_initial_function" ref="a82e8f16c4644843f561a5e9e14d817dc" args="(eq_base_init_func_boost func)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, class TypeBoundaryBase = EqBoundaryBase&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_slaughter_f_e_m_1_1_eq_base.html">SlaughterFEM::EqBase</a>&lt; Type, TypeBoundaryBase &gt;::<a class="el" href="class_slaughter_f_e_m_1_1_eq_base.html#a77adb3eb00c99dd5cd350ebfb386998d">add_initial_function</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_e_mcommon.html#gaa2cfca47e0fda7e9c260b0e6471a9f90">eq_base_init_func_boost</a>&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add function pointer to act as initialization function using boost::function indirectly. </p>
<p>The initial conditions for the the equation must be specified, this version takes the function pointer and converts it to a boost::function and uses the overloaded version of the <code>add_initial_function</code> to apply the function to the equation system.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>A function pointer to the initialization function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a34534f74c45909a599d7edbfde107d46"></a><!-- doxytag: member="SlaughterFEM::EqBase::add_initial_function" ref="a34534f74c45909a599d7edbfde107d46" args="(boost::function&lt; void(DenseVector&lt; Number &gt; &amp;output, const Point &amp;, const Real)&gt; bst_fptr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, class TypeBoundaryBase = EqBoundaryBase&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_slaughter_f_e_m_1_1_eq_base.html">SlaughterFEM::EqBase</a>&lt; Type, TypeBoundaryBase &gt;::<a class="el" href="class_slaughter_f_e_m_1_1_eq_base.html#a77adb3eb00c99dd5cd350ebfb386998d">add_initial_function</a> </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; void(DenseVector&lt; Number &gt; &amp;output, const Point &amp;, const Real)&gt;&#160;</td>
          <td class="paramname"><em>bst_fptr</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a boost::function pointer act as initialization function. </p>
<p>The initial conditions for equation must be specified, this function may be passed to the <a class="el" href="class_slaughter_f_e_m_1_1_eq_base.html" title="A template base class for using libmesh to solve equations.">EqBase</a> class using a boost::function which allows for extreme flexibility when binding is used.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bst_fptr</td><td>A boost::function that points to the initialization function or class </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a308250b3db51f34ae39dc4ec3927fcda"></a><!-- doxytag: member="SlaughterFEM::EqBase::get_boundary_index" ref="a308250b3db51f34ae39dc4ec3927fcda" args="(const int id)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, class TypeBoundaryBase = EqBoundaryBase&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;int&gt; <a class="el" href="class_slaughter_f_e_m_1_1_eq_base.html">SlaughterFEM::EqBase</a>&lt; Type, TypeBoundaryBase &gt;::<a class="el" href="class_slaughter_f_e_m_1_1_eq_base.html#a308250b3db51f34ae39dc4ec3927fcda">get_boundary_index</a> </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A method for getting a vector of indices for the boundary id. </p>
<p>This is a useful function for finding a boundary object with a specific id or to test if an id has been used.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A vector containing the index value of the given id. There should be only one value to this vector, but if empty the boundary doesn't exist. The id's are checked for uniqueness when they are added.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The boundary id to search</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_slaughter_f_e_m_1_1_heat_eq.html" title="A class for solving the heat equation with libMesh.">HeatEq</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abb60c3ae168ffdeb7df94831c6ff3a4e"></a><!-- doxytag: member="SlaughterFEM::EqBase::init_equation_system" ref="abb60c3ae168ffdeb7df94831c6ff3a4e" args="(Real t_initial=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, class TypeBoundaryBase = EqBoundaryBase&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="class_slaughter_f_e_m_1_1_eq_base.html">SlaughterFEM::EqBase</a>&lt; Type, TypeBoundaryBase &gt;::<a class="el" href="class_slaughter_f_e_m_1_1_eq_base.html#abb60c3ae168ffdeb7df94831c6ff3a4e">init_equation_system</a> </td>
          <td>(</td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>t_initial</em> = <code>0</code></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializes the equation system. </p>
<p>This function must be called before the equation is solved, but after all of the boundaries are defined. It does two things, adds the dirichlet conditions and then calls the libMesh equation systems init() function. </p>

</div>
</div>
<a class="anchor" id="a1abc4c56b6027b5ab67bbab8b3d97842"></a><!-- doxytag: member="SlaughterFEM::EqBase::set_refinement_levels" ref="a1abc4c56b6027b5ab67bbab8b3d97842" args="(double refine_fraction, double coarsen_fraction, int max_h_level)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, class TypeBoundaryBase = EqBoundaryBase&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_slaughter_f_e_m_1_1_eq_base.html">SlaughterFEM::EqBase</a>&lt; Type, TypeBoundaryBase &gt;::<a class="el" href="class_slaughter_f_e_m_1_1_eq_base.html#a1abc4c56b6027b5ab67bbab8b3d97842">set_refinement_levels</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>refine_fraction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>coarsen_fraction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_h_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the mesh refienement critiera. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">refine_fraction</td><td>maximum portion of elements for refinement </td></tr>
    <tr><td class="paramname">coarsen_fraction</td><td>maximum portion of elements for coarsening </td></tr>
    <tr><td class="paramname">max_h_level</td><td>the maximum refinements allowed for an element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9007ab95daa89b5dee8c09508ff02fa3"></a><!-- doxytag: member="SlaughterFEM::EqBase::solve" ref="a9007ab95daa89b5dee8c09508ff02fa3" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, class TypeBoundaryBase = EqBoundaryBase&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="class_slaughter_f_e_m_1_1_eq_base.html">SlaughterFEM::EqBase</a>&lt; Type, TypeBoundaryBase &gt;::<a class="el" href="class_slaughter_f_e_m_1_1_eq_base.html#a9007ab95daa89b5dee8c09508ff02fa3">solve</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solves the equation system for this class. </p>
<p>When mesh refinement is used the equation is iteratively solves using Kelly error estimatition, otherwise it simply uses the libMesh equation systems <a class="el" href="class_slaughter_f_e_m_1_1_eq_base.html#a9007ab95daa89b5dee8c09508ff02fa3" title="Solves the equation system for this class.">solve()</a> command.</p>
<p>This is a virtual function to allow the user to change the solution behavior in the derived class. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Mesh refinement is not tested. </dd></dl>

</div>
</div>
<a class="anchor" id="a49aee018d9e5bb74ccceb2c0be3dd96b"></a><!-- doxytag: member="SlaughterFEM::EqBase::update_solution" ref="a49aee018d9e5bb74ccceb2c0be3dd96b" args="(Real time, Real dt)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, class TypeBoundaryBase = EqBoundaryBase&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="class_slaughter_f_e_m_1_1_eq_base.html">SlaughterFEM::EqBase</a>&lt; Type, TypeBoundaryBase &gt;::<a class="el" href="class_slaughter_f_e_m_1_1_eq_base.html#a49aee018d9e5bb74ccceb2c0be3dd96b">update_solution</a> </td>
          <td>(</td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Updates the solution with time. </p>
<p>Passes the current solution to the old solution and reapplies the dirichlet boundary constraints</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>The current time </td></tr>
    <tr><td class="paramname">dt</td><td>The change in time </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4e952640e5fa5efceba09cbfaa8e751b"></a><!-- doxytag: member="SlaughterFEM::EqBase::use_refinement" ref="a4e952640e5fa5efceba09cbfaa8e751b" args="(int n=5)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, class TypeBoundaryBase = EqBoundaryBase&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_slaughter_f_e_m_1_1_eq_base.html">SlaughterFEM::EqBase</a>&lt; Type, TypeBoundaryBase &gt;::<a class="el" href="class_slaughter_f_e_m_1_1_eq_base.html#a4e952640e5fa5efceba09cbfaa8e751b">use_refinement</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em> = <code>5</code></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable mesh refinement. </p>
<p>This enables adaptive mesh refinement using the libMesh KellyErrorEstimation.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The maximum number of refinement iterations</td></tr>
  </table>
  </dd>
</dl>
<p>The set_refinement_levels function provides the ability to change the various refinement parameters, this function sets the defaults for these parameters at 0.8, 0.07, and 5. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/fem/common/<a class="el" href="eq__base_8h.html">eq_base.h</a></li>
</ul>
</div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespace_slaughter_f_e_m.html">SlaughterFEM</a>      </li>
      <li class="navelem"><a class="el" href="class_slaughter_f_e_m_1_1_eq_base.html">EqBase</a>      </li>

    <li class="footer">Generated on Tue Jun 26 2012 17:04:48 for NSF Postdoctoral Research by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
