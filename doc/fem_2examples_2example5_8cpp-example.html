<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>NSF Postdoctoral Research: fem/examples/example5.cpp</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://www.mathjax.org/mathjax/MathJax.js"></script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">NSF Postdoctoral Research
   
   </div>
   <div id="projectbrief">A set of C++ code developed by Andrew E. Slaughter</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('fem_2examples_2example5_8cpp-example.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">fem/examples/example5.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<p>A test function for testing the HeatEq class.</p>
<p>This class implements Example 8-1 from Bhatti (2005; p. 552). Run the program with the <code>--help</code> flag for a complete list of run-time options.</p>
<div class="fragment"><pre class="fragment">
<span class="comment">// Standard library includes  </span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;algorithm&gt;</span>
<span class="preprocessor">#include &lt;math.h&gt;</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;functional&gt;</span>

<span class="comment">// BOOST includes</span>
<span class="preprocessor">#include &lt;boost/shared_ptr.hpp&gt;</span>
<span class="preprocessor">#include &lt;boost/function.hpp&gt;</span>
<span class="preprocessor">#include &lt;boost/bind.hpp&gt;</span>

<span class="comment">// Include my fem library</span>
<span class="preprocessor">#include &quot;<a class="code" href="fem_2include_8h.html" title="General include file for the fem library.">fem/include.h</a>&quot;</span>
<span class="keyword">using namespace </span>SlaughterFEM;

<span class="comment">// Include my common library</span>
<span class="preprocessor">#include &quot;<a class="code" href="common_2include_8h.html" title="General include file for the common library.">common/include.h</a>&quot;</span>
<span class="keyword">using namespace </span>SlaughterCommon;

<span class="comment">// libMesh</span>
<span class="preprocessor">#include &lt;libmesh.h&gt;</span>
<span class="preprocessor">#include &lt;libmesh_common.h&gt;</span>

<span class="preprocessor">#include &lt;exodusII_io.h&gt;</span>
<span class="preprocessor">#include &lt;vtk_io.h&gt;</span>

<span class="preprocessor">#include &lt;mesh.h&gt;</span>
<span class="preprocessor">#include &lt;mesh_generation.h&gt;</span>

<span class="preprocessor">#include &lt;equation_systems.h&gt;</span>
<span class="preprocessor">#include &lt;transient_system.h&gt;</span>
<span class="preprocessor">#include &lt;nonlinear_implicit_system.h&gt;</span>
<span class="preprocessor">#include &lt;explicit_system.h&gt;</span>

<span class="preprocessor">#include &lt;fe.h&gt;</span>
<span class="preprocessor">#include &lt;fe_type.h&gt;</span>
<span class="preprocessor">#include &lt;quadrature_gauss.h&gt;</span>
<span class="preprocessor">#include &lt;dof_map.h&gt;</span>
<span class="preprocessor">#include &lt;sparse_matrix.h&gt;</span>
<span class="preprocessor">#include &lt;numeric_vector.h&gt;</span>
<span class="preprocessor">#include &lt;dense_matrix.h&gt;</span>
<span class="preprocessor">#include &lt;dense_vector.h&gt;</span>

<span class="preprocessor">#include &lt;point_locator_tree.h&gt;</span>
  
<span class="comment">// Bring in everything from the libMesh namespace</span>
<span class="keyword">using namespace </span>libMesh;

<span class="comment">// A class for containing the nodal data</span>
<span class="keyword">class </span>EqVolAvgData : <span class="keyword">public</span> <a name="_a0"></a><a class="code" href="class_slaughter_f_e_m_1_1_eq_data_base.html" title="A base class including nodal data.">EqDataBase</a>{
   
   <span class="keyword">public</span>:
   
      <span class="comment">// Class constructor</span>
      EqVolAvgData(EquationSystems&amp; sys) : <a class="code" href="class_slaughter_f_e_m_1_1_eq_data_base.html" title="A base class including nodal data.">EqDataBase</a>(sys, <span class="stringliteral">&quot;eq_data&quot;</span>) : velocity_linker(sys){
         add_variable(<span class="stringliteral">&quot;epsilon&quot;</span>);      <span class="comment">// volume fraction</span>
         <span class="comment">//add_variable(&quot;tau_1&quot;);         // first stabilization term</span>
         <span class="comment">//add_variable(&quot;element_length&quot;); // element length, Eq. 69, h</span>
         <span class="comment">//add_variable(&quot;P_alpha&quot;);    // stablization term, Eq. 75</span>
         
         get_system().init();       <span class="comment">// initialize the data storage system</span>
      }
         
      <span class="comment">// This is called when the solution is updated</span>
      <span class="keywordtype">void</span> value(DenseVector&lt;Number&gt;&amp; output, <span class="keyword">const</span> Point&amp; p, <span class="keyword">const</span> Real){
         
         <span class="comment">// Gather the time from the system</span>
         Real t = get_system().time;
         
         <span class="comment">// Return the values of k and cp</span>
         output.resize(2);
         output(0) = epsilon(p);
         output(1) = tau_1(p);
         output(2) = element_length(p);
      }     

      


      <span class="comment">// A function for returning the velocity, from the momentum equation</span>
      DenseVector&lt;Number&gt; velocity(<span class="keyword">const</span> Point&amp; p){
         
         <span class="comment">// Get a reference to the system object for the Momentum equation</span>
         TransientNonlinearImplicitSystem&amp; momentum_system = 
            eq_sys.get_system&lt;TransientNonlinearImplicitSystem&gt;(<span class="stringliteral">&quot;momentum&quot;</span>);
         
         <span class="comment">// Get the number of dimensions</span>
         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = dimension();  
                        
         <span class="comment">// Collect the velocity vector components</span>
         DenseVector&lt;Number&gt; s(dim);
         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> d = 0; d &lt; dim; d++){
            s(d) = momentum_system.point_value(d, p);
         }
         
         <span class="comment">// Return the vector</span>
         <span class="keywordflow">return</span> s;
      }
      
      vector&lt;Number&gt; velocity(<span class="keyword">const</span> Point&amp; p){
         
         DenseVector&lt;Number&gt; a = velocity(p);
         vector&lt;Number&gt; b;
         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; a.size(); i++){
            b.push_back(a(i));
         }
         
         <span class="keywordflow">return</span> b;
      }
      
      <span class="comment">// A function for returning the volume fraction</span>
      Number epsilon(<span class="keyword">const</span> Point&amp; p){
         <span class="keywordflow">return</span> 1;
      }

      <span class="comment">// Returns the \tau_1 value for the advective stabilization term (Eq. 63)</span>
      Number tau_1(<span class="keyword">const</span> Point&amp; p){
         
         <span class="comment">// Indicate the use of pow and min function from std library</span>
         <span class="keyword">using</span> std::pow;
         <span class="keyword">using</span> std::min;

         <span class="comment">// Collect the constants</span>
         Number Da = eq_sys.parameters.get&lt;Number&gt;(<span class="stringliteral">&quot;Da&quot;</span>);
         Number Pr = eq_sys.parameters.get&lt;Number&gt;(<span class="stringliteral">&quot;Pr&quot;</span>);         
         
         <span class="comment">// Collect the data evaluated at current point</span>
         Number eps = epsilon(p);
         Number h = element_length(p);
         DenseVector&lt;Number&gt; v = velocity(p);

         <span class="comment">// Compute the first \tau value</span>
         Number tau_1a = pow(eps, 2) / pow((1-eps), 2) * (Da / Pr);
         
         <span class="comment">// Compute the \tau_{SUPG} value, Eq. 64</span>
         Number v_norm = v.l2_norm();        <span class="comment">// ||v^h||</span>
         Number Re = v_norm * h / (2 * Pr);     <span class="comment">// Re_v, Eq. 67</span>
         
         <span class="comment">// z(Re) of Eq. 70</span>
         Number zRe;
         <span class="keywordflow">if</span> (Re &gt;= 0 &amp;&amp; Re &lt;= 3){
            zRe = Re/3;
         } <span class="keywordflow">else</span> {
            zRe = 1;
         }        

         <span class="comment">// The \tau_{SUPG} value</span>
         Number tau_1b = eps * h / (2 * v_norm) * zRe;
         
         <span class="comment">// Return the minimum of the two values computed</span>
         <span class="keywordflow">return</span> min(tau_1a, tau_1b);
      }
      
      <span class="comment">// Returns the element length, Eq. 69</span>
      Number element_length(Elem* elem){
            
         <span class="comment">// Get the number of dimensions</span>
         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = dimension();  
            
         <span class="comment">// Get the variable index of the element length</span>
         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx = get_system().variable_number(<span class="stringliteral">&quot;element_length&quot;</span>);   
            
         <span class="comment">// Get the FE type for the element length variable</span>
         FEType fe_type = get_system().variable_type(idx);

         <span class="comment">// Build a Finite Element object of the specified type. </span>
         AutoPtr&lt;FEBase&gt; fe (FEBase::build(dim, fe_type));

         <span class="comment">// A Gauss quadrature rule for numerical integration.</span>
         QGauss qrule (dim, fe_type.default_quadrature_order());

         <span class="comment">// Tell the finite element object to use our quadrature rule.</span>
         fe-&gt;attach_quadrature_rule(&amp;qrule);

         <span class="comment">// The element shape functions evaluated at the quadrature points.</span>
         <span class="keyword">const</span> std::vector&lt;std::vector&lt;RealGradient&gt; &gt;&amp; dN = fe-&gt;get_dphi();
                  
         <span class="comment">// Re-initialize the fe system for this element</span>
         fe-&gt;reinit(elem);
         
         <span class="comment">// Initialize the element length parameter, h</span>
         Number h = 0;
         
         <span class="comment">// Get a vector of the points for the quadrature rule</span>
         vector&lt;Point&gt;&amp; pvec = qrule.get_points();
         
         <span class="comment">/* Compute the element length at the Gauss points, this </span>
<span class="comment">          * differs from Eq. 69 which uses nodes.</span>
<span class="comment">          */</span> 
          
         <span class="comment">// Loop over Gauss points (nodal summation of Eq. 69)</span>
         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> qp = 0; qp &lt; qrule.n_points(); qp++){
            
            <span class="comment">// Get the velocity vector</span>
            DenseVector&lt;Number&gt; s = velocity(pvec[qp]);
      
            <span class="comment">// Compute the L2-norm of the velocity vector</span>
            Number s_norm = s.l2_norm();
            
            <span class="comment">// Loop over shape functions</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dN.size(); i++){
            
               <span class="comment">// If zero velocity, then element length is set to 0</span>
               <span class="keywordflow">if</span> (s_norm == 0 ){
                  h = 0;
               
               <span class="comment">// Else compute the element length</span>
               } <span class="keywordflow">else</span> {
                  
                  <span class="comment">// Dot product, using normalized velocity</span>
                  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> d = 0; d &lt; dim; d++){
                     h += 2 * dN[i][qp](d) * s(d)/s_norm;
                  }
               }
            }
         }
         
         <span class="comment">// Return the value of the element length</span>
         <span class="keywordflow">return</span> h;   
      }

      <span class="comment">// Returns the P_alpha stabilization term, Eq. 75</span>
      Number P_alpha(<span class="keyword">const</span> Point&amp; p){
            
         <span class="comment">// Get the number of dimensions</span>
         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = dimension();  
            
         <span class="comment">// Get the variable index of the element length</span>
         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx = get_system().variable_number(<span class="stringliteral">&quot;element_length&quot;</span>);   
            
         <span class="comment">// Get the FE type for the element length variable</span>
         FEType fe_type = get_system().variable_type(idx);

         <span class="comment">// Build a Finite Element object of the specified type. </span>
         AutoPtr&lt;FEBase&gt; fe (FEBase::build(dim, fe_type));

         <span class="comment">// A Gauss quadrature rule for numerical integration.</span>
         QGauss qrule (dim, fe_type.default_quadrature_order());

         <span class="comment">// Tell the finite element object to use our quadrature rule.</span>
         fe-&gt;attach_quadrature_rule(&amp;qrule);

         <span class="comment">// The element shape functions evaluated at the quadrature points.</span>
         <span class="keyword">const</span> std::vector&lt;std::vector&lt;RealGradient&gt; &gt;&amp; dN = fe-&gt;get_dphi();
         
         <span class="comment">// Get a reference to the mesh</span>
         MeshBase&amp; mesh = eq_sys.get_mesh();
         
         <span class="comment">// Determine the element that contains the point</span>
         PointLocatorTree locate(mesh);
         
         <span class="comment">// Locate the element</span>
         <span class="keyword">const</span> Elem* elem = locate(p);
         
         <span class="comment">// Re-initialize the fe system for this element</span>
         fe-&gt;reinit(elem);
         
         <span class="comment">// Initialize the element length parameter, h</span>
         Number P = 0;
         
         <span class="comment">// Get a vector of the points for the quadrature rule</span>
         vector&lt;Point&gt;&amp; pvec = qrule.get_points();
         
         <span class="comment">// Loop over Gauss points (nodal summation of Eq. 69)</span>
         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> qp = 0; qp &lt; qrule.n_points(); qp++){
            
            <span class="comment">// Gather the necessary components</span>
            Number eps = epsilon(pvec[qp]);
            Number tau = tau_1(pvec[qp]);
            DenseVector&lt;Number&gt; v = velocity(pvec[qp]);
            
            <span class="comment">// Loop over shape functions</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dN.size(); i++){
            
               <span class="comment">// Dot product, using normalized velocity</span>
               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> d = 0; d &lt; dim; d++){
                  P += (1 / eps) * tau * v(d) * dN[i][qp](d);
               }
               
            }
         }
         
         <span class="comment">// Return the value P_{\alpha}^e</span>
         <span class="keywordflow">return</span> P;   
      }
   
   <span class="keyword">private</span>:
      <a name="_a1"></a><a class="code" href="class_slaughter_f_e_m_1_1_eq_variable_linker.html" title="A generic class to link system variables between classes.">EqVariableLinker</a> velocity_linker;

};

<span class="comment">// Function for initializing Momentum Eq.</span>
<span class="keywordtype">void</span> momentum_init_velocity(DenseVector&lt;Number&gt;&amp; output, <span class="keyword">const</span> Point&amp;, <span class="keyword">const</span> Real){
   output(0) = 0;
   output(1) = 2;
}

<span class="comment">// Function for initializing Energy Eq.</span>
<span class="keywordtype">void</span> energy_init_enthalpy(DenseVector&lt;Number&gt;&amp; output, <span class="keyword">const</span> Point&amp;, <span class="keyword">const</span> Real){
   output(0) = 0;
}

<span class="comment">// Function prototype for assembly of Energy Eq.</span>
<span class="keywordtype">void</span> energy_assemble(EquationSystems&amp; eq_sys, <span class="keyword">const</span> std::string&amp; system_name);


<span class="comment">// Initialize Momentum Eq.</span>
<span class="keywordtype">void</span> init_function(EquationSystems&amp; es, <span class="keyword">const</span> std::string&amp; system_name){
   
   <span class="comment">// Get a reference to the system</span>
   TransientNonlinearImplicitSystem&amp; system =
     es.get_system&lt;TransientNonlinearImplicitSystem&gt;(system_name);

   <span class="comment">// Create a function acceptable for solution projection</span>
   boost::function&lt; void (DenseVector&lt;Number&gt;&amp;, <span class="keyword">const</span> Point&amp;, <span class="keyword">const</span> Real)&gt; fptr;
   
   <span class="comment">// Link the correct function</span>
   <span class="keywordflow">if</span> (system_name.compare(<span class="stringliteral">&quot;momentum&quot;</span>) == 0){
      fptr = momentum_init_velocity;
   
   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (system_name.compare(<span class="stringliteral">&quot;energy&quot;</span>) == 0){
      fptr = energy_init_enthalpy;
   }

   <span class="comment">// Convert into a libmesh acceptable format</span>
   <a name="_a2"></a><a class="code" href="class_slaughter_f_e_m_1_1_my_analytic_function.html" title="A class for using boost::functions with libmesh.">MyAnalyticFunction&lt;Number&gt;</a> fobj(fptr);

   <span class="comment">// Project the solution </span>
   system.project_solution(&amp;fobj);
}
        

<span class="comment">// Begin main function</span>
<span class="keywordtype">int</span> <a name="a3"></a><a class="code" href="v2m_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97" title="Main program for generating meshes from 3D image data.">main</a> (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv){

    <span class="comment">// Initialize libraries</span>
    LibMeshInit init (argc, argv);

   <span class="comment">// Generate a mesh object</span>
   <a name="_a4"></a><a class="code" href="class_slaughter_f_e_m_1_1_my_mesh.html" title="Adds additional boundary identification behavior to libMesh::Mesh class.">MyMesh</a> mesh;
   
   <span class="comment">// Create a 2D grid</span>
   MeshTools::Generation::build_square(mesh, 1, 1, 0., 1, 0., 1, QUAD4);
   mesh.all_first_order();
   Order order = FIRST;

   <span class="comment">// Create an equation system</span>
   EquationSystems eq_sys(mesh); 

   <span class="comment">// Add constants</span>
   eq_sys.parameters.set&lt;Number&gt;(<span class="stringliteral">&quot;Da&quot;</span>) = 1;
   eq_sys.parameters.set&lt;Number&gt;(<span class="stringliteral">&quot;Pr&quot;</span>) = 1;
   eq_sys.parameters.set&lt;Number&gt;(<span class="stringliteral">&quot;dt&quot;</span>) = 0.01;

   <span class="comment">// Create momentum equation</span>
   TransientNonlinearImplicitSystem&amp; momentum =
      eq_sys.add_system&lt;TransientNonlinearImplicitSystem&gt;(<span class="stringliteral">&quot;momentum&quot;</span>);

   <span class="comment">// Add 2D velocity variables</span>
   momentum.add_variable(<span class="stringliteral">&quot;vx&quot;</span>, order);
   momentum.add_variable(<span class="stringliteral">&quot;vy&quot;</span>, order);
   
   <span class="comment">// Attach initialization function</span>
   momentum.attach_init_function(init_function);
   momentum.init();

   <span class="comment">// Create the energy equation</span>
   TransientNonlinearImplicitSystem&amp; energy =
      eq_sys.add_system&lt;TransientNonlinearImplicitSystem&gt;(<span class="stringliteral">&quot;energy&quot;</span>);
   
   <span class="comment">// Add the enthalpy</span>
   energy.add_variable(<span class="stringliteral">&quot;h&quot;</span>, order);
   
   <span class="comment">// Attach initialization function</span>
   energy.attach_init_function(init_function);
   
   <span class="comment">// Attach assembly function</span>
   energy.attach_assemble_function(energy_assemble);

   <span class="comment">// Initialize the energy</span>
   energy.init();

   <span class="comment">// Create the data class (Initializes upon creation)</span>
   EqData data(eq_sys);
   
   <span class="comment">// Project the solution at time t = 0</span>
   data.update_solution(0);
   
   <span class="comment">// Output the data</span>
   ExodusII_IO(mesh).write_equation_systems(<span class="stringliteral">&quot;example5.ex2&quot;</span>, eq_sys);

   <span class="comment">// Call the assembly function for testing</span>
   energy_assemble(eq_sys, <span class="stringliteral">&quot;energy&quot;</span>);



} <span class="comment">// end main</span>


<span class="comment">// Energy equation assembly function</span>
<span class="comment">// Equation references are from Zabaras and Samanta, 2004</span>
<span class="keywordtype">void</span> energy_assemble(EquationSystems&amp; eq_sys, <span class="keyword">const</span> std::string&amp; system_name){

   <span class="comment">// Check that we are assembling the correct system</span>
   libmesh_assert (system_name == <span class="stringliteral">&quot;energy&quot;</span>);

   <span class="comment">// Get a constant reference to the mesh object.</span>
   <span class="keyword">const</span> MeshBase&amp; mesh = eq_sys.get_mesh();

   <span class="comment">// The dimension that we are running</span>
   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = mesh.mesh_dimension();

   <span class="comment">// Get a reference to the system object for the Energy equation</span>
   TransientNonlinearImplicitSystem&amp; system = 
      eq_sys.get_system&lt;TransientNonlinearImplicitSystem&gt;(system_name);
      
   <span class="comment">// Get a reference to the system object for the Momentum equation (velocity)</span>
   TransientNonlinearImplicitSystem&amp; momentum_system = 
      eq_sys.get_system&lt;TransientNonlinearImplicitSystem&gt;(<span class="stringliteral">&quot;momentum&quot;</span>);
         
   <span class="comment">// Get a constant reference to the Finite Element type</span>
   <span class="comment">// for the first (and only) variable in the system.</span>
   FEType fe_type = system.variable_type(0);

   <span class="comment">// Build a Finite Element object of the specified type. </span>
   AutoPtr&lt;FEBase&gt; fe      (FEBase::build(dim, fe_type));
   AutoPtr&lt;FEBase&gt; fe_face (FEBase::build(dim, fe_type));

   <span class="comment">// A Gauss quadrature rule for numerical integration.</span>
   <span class="comment">// Let the \p FEType object decide what order rule is appropriate.</span>
   QGauss qrule (dim,   fe_type.default_quadrature_order());
   QGauss qface (dim-1, fe_type.default_quadrature_order());

   <span class="comment">// Tell the finite element object to use our quadrature rule.</span>
   fe-&gt;attach_quadrature_rule      (&amp;qrule);
   fe_face-&gt;attach_quadrature_rule (&amp;qface);

   <span class="comment">// Here we define some references to cell-specific data that</span>
   <span class="comment">// will be used to assemble the linear system.  We will start</span>
   <span class="comment">// with the element Jacobian * quadrature weight at each integration point.   </span>
   <span class="keyword">const</span> std::vector&lt;Real&gt;&amp; JxW      = fe-&gt;get_JxW();
   <span class="keyword">const</span> std::vector&lt;Real&gt;&amp; JxW_face = fe_face-&gt;get_JxW();

   <span class="comment">// The element shape functions evaluated at the quadrature points.</span>
   <span class="keyword">const</span> std::vector&lt;std::vector&lt;Real&gt; &gt;&amp; N = fe-&gt;get_phi();
   <span class="keyword">const</span> std::vector&lt;std::vector&lt;Real&gt; &gt;&amp; N_face = fe_face-&gt;get_phi();

   <span class="comment">// Element shape function gradients evaluated at quadrature points</span>
   <span class="keyword">const</span> std::vector&lt;std::vector&lt;RealGradient&gt; &gt;&amp; dN = fe-&gt;get_dphi();

   <span class="comment">// The XY locations of the quadrature points used for face integration</span>
   <span class="keyword">const</span> std::vector&lt;Point&gt;&amp; qface_points = fe_face-&gt;get_xyz();

   <span class="comment">// A reference to the \p DofMap object for this system.</span>
   <span class="keyword">const</span> DofMap&amp; dof_map = system.get_dof_map();

   <span class="comment">// Define data structures to contain the element matrix</span>
   <span class="comment">// and right-hand-side vector contribution (Eq. 107)  </span>
   DenseMatrix&lt;Number&gt; Me;       <span class="comment">// [\hat{M} + \hat{M}_{\delta}]</span>
   DenseMatrix&lt;Number&gt; Ne;       <span class="comment">// [\hat{N} + \hat{N}_{\delta}]</span>
   DenseMatrix&lt;Number&gt; Ke;       <span class="comment">// [\hat{K} + \hat{K}_{\delta}]</span>
   DenseVector&lt;Number&gt; Fe;       <span class="comment">// [\hat{F} + \hat{F}_{\delta}]</span>
   <span class="comment">//DenseVector&lt;Number&gt; Fe_old;    // element force vector (previous time)</span>
   DenseVector&lt;Number&gt; h_old;    <span class="comment">// element enthalpy vector (previous time)</span>
   
   DenseVector&lt;Number&gt; v_old;    <span class="comment">// element velocity vector (previous time)</span>

   DenseMatrix&lt;Number&gt; Mstar;    <span class="comment">// general time integration stiffness matrix (Eq. 125)</span>
   DenseVector&lt;Number&gt; R;        <span class="comment">// general time integration force vector (Eq. 126)</span>

   <span class="comment">// Storage for the degree of freedom indices</span>
   std::vector&lt;unsigned int&gt; dof_indices;

   <span class="comment">// Here we extract the parameters that will be needed</span>
   <span class="keyword">const</span> Real dt = eq_sys.parameters.get&lt;Real&gt;(<span class="stringliteral">&quot;dt&quot;</span>);    <span class="comment">// time step</span>
   Real time = system.time;         <span class="comment">// current time</span>

   <span class="comment">// Loop over all the elements in the mesh that are on local processor</span>
   MeshBase::const_element_iterator       el     = mesh.active_local_elements_begin();
   <span class="keyword">const</span> MeshBase::const_element_iterator end_el = mesh.active_local_elements_end(); 

   <span class="keywordflow">for</span> ( ; el != end_el; ++el){    

      <span class="comment">// Pointer to the element current element</span>
      <span class="keyword">const</span> Elem* elem = *el;

      <span class="comment">// Get the degree of freedom indices for the current element</span>
      dof_map.dof_indices(elem, dof_indices);

      <span class="comment">// Compute the element-specific data for the current element</span>
      fe-&gt;reinit(elem);

      <span class="comment">// Zero the element matrices and vectors</span>
      Me.resize (dof_indices.size(), dof_indices.size());
      Ne.resize (dof_indices.size(), dof_indices.size());
      Ke.resize (dof_indices.size(), dof_indices.size());
      Fe.resize (dof_indices.size());
      h_old.resize (dof_indices.size());

      <span class="comment">// Compute the RHS and mass and stiffness matrix for this element (Me)</span>
      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> qp = 0; qp &lt; qrule.n_points(); qp++){
         
         <span class="comment">// Get the velocity at this Gauss point (std::vector format)</span>
         vector v(3,0); <span class="comment">// Need to get this from my data class</span>
         
         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; N.size(); i++){
            
            <span class="comment">// This is not correct</span>
            Fe(i) += 0; 

            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; N.size(); j++){    

               Me(i,j) += JxW[qp]*(N[i][qp]) * N[j][qp]);  
               Ne(i,j) += JxW[qp]*(N[i][qp]*v[j]*dN[j][qp]);   
            }
         }
      }
<span class="comment">/*   </span>
<span class="comment">       // BOUNDARY CONDITIONS    </span>
<span class="comment">      // Loop through each side of the element for applying boundary conditions</span>
<span class="comment">      for (unsigned int s = 0; s &lt; elem-&gt;n_sides(); s++){</span>
<span class="comment">         </span>
<span class="comment">         // Only consider the side if it does not have a neighbor</span>
<span class="comment">         if (elem-&gt;neighbor(s) == NULL){</span>
<span class="comment">            </span>
<span class="comment">            // Pointer to current element side</span>
<span class="comment">            const AutoPtr&lt;Elem&gt; side = elem-&gt;side(s);</span>
<span class="comment">               </span>
<span class="comment">            // Boundary ID of the current side</span>
<span class="comment">            int boundary_id = (mesh.boundary_info)-&gt;boundary_id(elem, s);</span>
<span class="comment"></span>
<span class="comment">            // Get index of the boundary class with the same id</span>
<span class="comment">            // this vector is empty if there is no match and only</span>
<span class="comment">            // contains a single value if there is a match</span>
<span class="comment">            std::vector&lt;int&gt; idx = get_boundary_index(boundary_id);  </span>
<span class="comment">            </span>
<span class="comment">            // Continue of there is a match                 </span>
<span class="comment">            if(!idx.empty()){                   </span>
<span class="comment">                     </span>
<span class="comment">               // Compute the shape function values on the element face</span>
<span class="comment">               fe_face-&gt;reinit(elem, s);</span>
<span class="comment">                                 </span>
<span class="comment">               // Create a shared pointer to the boundary class   </span>
<span class="comment">               boost::shared_ptr&lt;HeatEqBoundaryBase&gt; ptr = bc_ptrs[idx[0]];</span>
<span class="comment">               </span>
<span class="comment">               // Determine the type of boundary considered</span>
<span class="comment">               std::string type = ptr-&gt;type;</span>
<span class="comment"></span>
<span class="comment">               // Loop through quadrature points</span>
<span class="comment">               for (unsigned int qp = 0; qp &lt; qface.n_points(); qp++){</span>
<span class="comment"></span>
<span class="comment">                  // DIRICHLET (libMesh version; handled at initialization)</span>
<span class="comment">                  if(type.compare(&quot;dirichlet&quot;) == 0){</span>
<span class="comment">                     // The dirichlet conditions are handled at initlization</span>
<span class="comment">                     // but I don&#39;t want to throw an error if they are</span>
<span class="comment">                     // encountered, so just do nothing</span>
<span class="comment">                     </span>
<span class="comment">                  // NEUMANN condition</span>
<span class="comment">                  } else if(type.compare(&quot;neumann&quot;) == 0){</span>
<span class="comment"></span>
<span class="comment">                     // Current and past flux values              </span>
<span class="comment">                     const Number q = ptr-&gt;q(qface_points[qp], time);</span>
<span class="comment">                     const Number q_old = ptr-&gt;q(qface_points[qp], time - dt);</span>
<span class="comment">                           </span>
<span class="comment">                     // Add values to Fe                 </span>
<span class="comment">                     for (unsigned int i = 0; i &lt; psi.size(); i++){</span>
<span class="comment">                        Fe(i)      += JxW_face[qp] * q * psi[i][qp];</span>
<span class="comment">                        Fe_old(i) += JxW_face[qp] * q_old * psi[i][qp];    </span>
<span class="comment">                     }  </span>
<span class="comment"></span>
<span class="comment">                  // CONVECTION boundary</span>
<span class="comment">                  } else if(type.compare(&quot;convection&quot;) == 0){  </span>
<span class="comment"></span>
<span class="comment">                     // Current and past h and T_inf</span>
<span class="comment">                     const Number h         = ptr-&gt;h(qface_points[qp], time);</span>
<span class="comment">                     const Number h_old    = ptr-&gt;h(qface_points[qp], time - dt);</span>
<span class="comment">                     const Number Tinf   = ptr-&gt;Tinf(qface_points[qp], time);</span>
<span class="comment">                     const Number Tinf_old = ptr-&gt;Tinf(qface_points[qp], time - dt);</span>
<span class="comment">                     </span>
<span class="comment">                     // Add values to Ke and Fe                </span>
<span class="comment">                     for (unsigned int i = 0; i &lt; psi.size(); i++){</span>
<span class="comment">                        Fe(i)      += (1) * JxW_face[qp] * h * Tinf * psi[i][qp];</span>
<span class="comment">                        Fe_old(i) += (1) * JxW_face[qp] * h_old * Tinf_old * psi[i][qp];</span>
<span class="comment">                        </span>
<span class="comment">                        for (unsigned int j = 0; j &lt; psi.size(); j++){</span>
<span class="comment">                           Ke(i,j) += JxW_face[qp] * psi[i][qp] * h * psi[j][qp];</span>
<span class="comment"></span>
<span class="comment">                        }     </span>
<span class="comment">                     }</span>
<span class="comment">            </span>
<span class="comment">                  // Un-registerd type    </span>
<span class="comment">                  } else {</span>
<span class="comment">                     printf(&quot;WARNING! The boundary type, %s, was not understood!\n&quot;, type.c_str());</span>
<span class="comment">               </span>
<span class="comment">                  }  // (end) type.compare(...) statemenst  </span>
<span class="comment">               } //(end) for (int qp = 0; qp &lt; qface.n_points(); qp++)  </span>
<span class="comment">            } // (end) if(!idx.empty)</span>
<span class="comment">         } // (end) if (elem-&gt;neighbor(s) == NULL){</span>
<span class="comment">      } // (end) for (int s = 0; s &lt; elem-&gt;n_sides(); s++)  </span>
<span class="comment"></span>
<span class="comment">      // Zero the pervious time-step temperature vector for this element</span>
<span class="comment">      u_old.resize(dof_indices.size());</span>
<span class="comment">      </span>
<span class="comment">      // Gather the temperatures at the nodes</span>
<span class="comment">      for (unsigned int i = 0; i &lt; psi.size(); i++){</span>
<span class="comment">         u_old(i) = system.old_solution(dof_indices[i]);</span>
<span class="comment">      }</span>
<span class="comment"></span>
<span class="comment">      // Build K_hat and F_hat (appends existing)</span>
<span class="comment">      K_hat.resize(dof_indices.size(), dof_indices.size());</span>
<span class="comment">      F_hat.resize(dof_indices.size());</span>
<span class="comment">      build_stiffness_and_rhs(K_hat, F_hat, Me, Ke, Fe_old, Fe, u_old, dt, theta);</span>
<span class="comment">      </span>
<span class="comment">      // Applies the dirichlet constraints to K_hat and F_hat</span>
<span class="comment">      dof_map.heterogenously_constrain_element_matrix_and_vector(K_hat, F_hat, dof_indices);</span>
<span class="comment">      </span>
<span class="comment">      // Apply the local components to the global K and F</span>
<span class="comment">      system.matrix-&gt;add_matrix(K_hat, dof_indices);</span>
<span class="comment">      system.rhs-&gt;add_vector(F_hat, dof_indices);  </span>
<span class="comment">*/</span>    
   } <span class="comment">// (end) for ( ; el != end_el; ++el)</span>

} <span class="comment">// (end) assemble()</span>




</pre></div> </div><!-- contents -->
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div>
  <div id="nav-path" class="navpath">
    <ul>

    <li class="footer">Generated on Mon Jun 18 2012 15:07:30 for NSF Postdoctoral Research by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
